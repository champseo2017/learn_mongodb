/* 

การรวมข้อมูล Aggregation

เมธอดการรวมข้อมูลของไปป์ไลน์
- ใช้เมธอด db.collection.aggregate()
รูปแบบ
db.collection.aggregate([ {<stage>}, ... ])

สเตจ (Stage)
สเตจการทำงานที่ใช้บ่อย

$match กลั่นกรองเอาเฉพาะด็อกคิวเมนต์ที่ตรงตามเงื่อนไขที่ระบุ
$group จัดกลุ่มด็อกคิวเมนต์และสามารถคำนวณค่าเก็บไว้ในเอาต์พุต
$project ส่งผ่านด็อกคิวเมนต์โดยเลือกเอาเฉพาะฟิลด์ที่ระบุ
$sort จัดเรียงด็อกคิวเมนต์ที่ได้รับเข้ามาทั้งหมด
$skip ข้ามด็อกคิวเมนต์ตามจำนวนที่ระบุและส่งที่เหลือออกไป
$limit จำกัดด็อกคิวเมนต์ที่ส่งออกไปตามจำนวนที่ระบุ
$unwind แยกสมาชิกในฟิลด์อาร์เรย์จากอินพุตออกเป็นด็อกคิวเมนต์
$count นับจำนวนด็อกคิวเมนต์ทั้งหมดที่รับเข้ามา
$lookup เรียกดูข้อมูลจากด๊อกคิวเมนต์ที่อยู่คนละคอลเล็กชันกัน


- การเรียกดูเฉพาะฟิลด์ข้อมูลที่ต้องการด้วย $project
$project กำหนดด็อกคิวเมนต์ที่จะส่งออกไป โดยเลือกเอาเฉพาะฟิลด์
กำหนด field: 0 ไม่มีฟิลด์นั้น และ firld: 1 จะมีฟิลด์นั้น
รูปแบบ 
{ $project: {"field1": x, "field2": x, ...} }


*/

// ตัวอย่าง เพิ่มรายการยอดขายหนังสือในคอลเล็กชัน sales จากนั้นใช้ $project กำหนดส่งด็อกคิวเมนต์ออกไปโดยมีเฉพาะฟิลด์ที่ระบุ คือ name และ sales
db.sales.insertMany([
  { name: "photoshop", cat: "graphic", sales: 2500, date: "2020-02-18" },
  { name: "excel", cat: "office", sales: 1990, date: "2020-01-12" },
  { name: "indesign", cat: "graphic", sales: 2850, date: "2020-08-07" },
  { name: "lightroom", cat: "graphic", sales: 2550, date: "2020-03-10" },
]);

// ใช้ $project กำหนดให้ด็อกคิวเมนต์ที่ส่งออกไปมีฟิลด์ name และ sales ส่วนฟิลด์ _id: ObjectId เป็นค่าเริ่มต้นอัตโนมัติ ถ้าไม่ต้องการให้กำหนดด้วย 0
db.sales.aggregate([{ $project: { name: 1, sales: 1 } }]);
