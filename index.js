/* 

การรวมข้อมูล Aggregation

เมธอดการรวมข้อมูลของไปป์ไลน์
- ใช้เมธอด db.collection.aggregate()
รูปแบบ
db.collection.aggregate([ {<stage>}, ... ])

สเตจ (Stage)
สเตจการทำงานที่ใช้บ่อย

$match กลั่นกรองเอาเฉพาะด็อกคิวเมนต์ที่ตรงตามเงื่อนไขที่ระบุ
$group จัดกลุ่มด็อกคิวเมนต์และสามารถคำนวณค่าเก็บไว้ในเอาต์พุต
$project ส่งผ่านด็อกคิวเมนต์โดยเลือกเอาเฉพาะฟิลด์ที่ระบุ
$sort จัดเรียงด็อกคิวเมนต์ที่ได้รับเข้ามาทั้งหมด
$skip ข้ามด็อกคิวเมนต์ตามจำนวนที่ระบุและส่งที่เหลือออกไป
$limit จำกัดด็อกคิวเมนต์ที่ส่งออกไปตามจำนวนที่ระบุ
$unwind แยกสมาชิกในฟิลด์อาร์เรย์จากอินพุตออกเป็นด็อกคิวเมนต์
$count นับจำนวนด็อกคิวเมนต์ทั้งหมดที่รับเข้ามา
$lookup เรียกดูข้อมูลจากด๊อกคิวเมนต์ที่อยู่คนละคอลเล็กชันกัน


- การจัดกลุ่มข้อมูลด้วย $group
เป็นการรวมกลุ่มด็อกคิวเมนต์ที่ข้อมูลเหมือนกันไว้ในกลุ่มเดียวกัน โดยมีฟิลด์ _id เก็บรายการของข้อมูลในแต่ละกลุ่มที่ไม่ซ้ำกัน
และสามารถเพิ่มฟิลด์ที่ใช้เก็บผลลัพธ์การคำนวณของข้อมูลในแต่ละกลุ่มตามนิพจน์ที่กำหนดไว้ เช่น ผลรวม จำนวน ค่าสูงสุด ค่าต่ำสุด และ ค่าเฉลี่ย

รูปแบบ
{
  $group: 
        {
          _id: <expression>, // Group By Expression
          <field> : { <accumulator1> : <expression1> },
        }
}

- _id จำเป็นต้องมี ใช้กำหนดว่าต้องการแบ่งกลุ่มตามกลุ่มของฟิลด์อะไร หรือหากไม่ต้องการให้กำหนดค่า null

- field สร้างฟิลด์จัดเก็บข้อมูลการคำนวณค่าในกลุ่มด้วยนิพจน์ที่กำหนด เช่น การหาจำนวน, ผลรวม

นิพจน์เพื่อคำนวณข้อมูลในกลุ่ม
$sum หาผลลรวมด็อกคิวเมนต์ภายในกลุ่ม
$avg หาค่าเฉลี่ยจากด็อกคิวเมนต์ภายในกลุ่ม
$min หาค่าต่ำสุดจากด็อกคิวเมนต์ภายในกลุ่ม
$max หาค่าสูงสุดจากด็อกคิวเมนต์ภายในกลุ่ม
$first หาค่าลำดับแรกจากด็อกคิวเมนต์ภายในกลุ่ม
$last หาค่าลำดับสุดท้ายจากด็อกคิวเมนต์ภายในกลุ่ม
$push แทรกค่าไปยังอาร์เรย์ในด็อกคิวเมนต์ผลลัพธ์
$addToSet แทรกค่าไปยังอาร์เรย์ในด็อกคิวเมนต์ผลลัพธ์แต่จะไม่สร้างซ้ำ


*/

// เรียกดูข้อมูลจากการเชื่อมคอลเล็กชันด้วย $lookup

/*
เป็นการเรียกดูข้อมูลด็อกคิวเมนต์จากต่างคอลเล็กชันกัน โดยกำหนดให้คอลเล็กชั่นหลักอยู่ฝั่งซ้ายแล้วเชื่อมกับคอลเล็กชันภายนอกอยู่ฝั่งขวา ซึ้งคอลเล็กชันทั้งสองจะต้องอยู่ในฐานข้อมูลเดียวกัน ผลลัพธ์ที่ได้จะมีฟิลด์อาร์เรย์ข้อมูลเพิ่มเข้ามา ซึ้งเกิดจากคอลเล็กชั่นฝั่งขวาที่เราเชื่อมนั่นเอง

รูปแบบ
{
  $lookup: {
    form: <collection to join>,
    locaField: <field from input documents>,
    foreigField: <field from documents of "from" collection>,
    as: <output array field>
  }
}

  Form: คอลเล็กชันที่จะเชื่อมต่อด้วยต้องอยู่ในฐานข้อมูลเดียวกัน
  localField: ฟิลด์จากคอลเล็กชันอินพุต
  foreignField: ฟิลด์จากคอลเล็กชันที่จะนำมาเชื่อมต่อ
  as: กำหนดชื่อฟิลด์อาร์เรย์ใหม่ที่เพิ่มเข้าไปในด็อกคิวเมนต์ผลลัพธ์

 การรวมข้อมูลที่มีวัตถุประสงค์อย่างเดียว
 เป็นการรวมด็อกคิวเมนต์จากคอลเล็กชันหนึ่งที่นำใช้งานทั่วไปแบบง่ายๆ ไม่ต้องมีความยืดหยุ่นและมีหลายกระบวนการเหมือนกับไปป์ไลน์ของ Aggregate และ map-reduce ได้แก่ เมธอด db.collection.estimatedDocumentCount(), db.collection.count() และ db.collection.distinct()

 count() เป็นการหาจำนวนของด็อกคิวเมนต์ทั้งหมดที่มีอยู่ในคอลเล็กชันปัจจุบัน เช่น หาจำนวนด็อกคิวเมนต์ในคอลเล็กชัน total ได้เท่ากับ 2

 distinct() เป็นการหาค่าในฟิลด์ที่ระบุจากคอลเล็กชันปัจจุบัน โดยค่าที่ได้จะแตกต่างกันหรือไม่ซ้ำกัน

*/

// ตัวอย่าง ให้เราเพิ่มด็อกคิวเมนต์เก็บข้อมูลคอมเมนต์สินค้าจากลูกค้าอยู่ในคอลเล็กชัน comment เพื่อจะมาดูว่ามีสินค้ารายการใดผิดพลาดในการผลิตบ่อย
db.comment.insertMany([
  {
    usr: "tara",
    product: "photoshop",
    comment: "page 15"
  },
  {
    usr: "tiwa",
    product: "word",
    comment: "page 16"
  },
  {
    usr: "nara",
    product: "photoshop",
    comment: "page 17"
  },
  {
    usr: "mana",
    product: "excel",
    comment: "page 18"
  }
])

// รวมข้อมูลด้วย Aggregate ด้วย $project แสดงข้อมูลสินค้าที่มีปัญหาจากฟิลด์ product: 1 และไม่แสดงฟิลด์ _id: 0 พบว่าจะแสดงรายชื่อสินค้าซ้ำกัน

db.comment.aggregate([
  {
    $project: {
      product: 1,
      _id: 0
    }
  }
])

// ใช้เมธอด distinct("product") เพื่อแสดงรายชื่อสินค้าต่างๆ ที่ได้รับการคอมเมนต์จากลูกค้าโดยจะแสดงรายชื่อไม่ซ้ำกัน
db.comment.distinct("product")