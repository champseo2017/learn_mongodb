/* 

การรวมข้อมูล Aggregation

เมธอดการรวมข้อมูลของไปป์ไลน์
- ใช้เมธอด db.collection.aggregate()
รูปแบบ
db.collection.aggregate([ {<stage>}, ... ])

สเตจ (Stage)
สเตจการทำงานที่ใช้บ่อย

$match กลั่นกรองเอาเฉพาะด็อกคิวเมนต์ที่ตรงตามเงื่อนไขที่ระบุ
$group จัดกลุ่มด็อกคิวเมนต์และสามารถคำนวณค่าเก็บไว้ในเอาต์พุต
$project ส่งผ่านด็อกคิวเมนต์โดยเลือกเอาเฉพาะฟิลด์ที่ระบุ
$sort จัดเรียงด็อกคิวเมนต์ที่ได้รับเข้ามาทั้งหมด
$skip ข้ามด็อกคิวเมนต์ตามจำนวนที่ระบุและส่งที่เหลือออกไป
$limit จำกัดด็อกคิวเมนต์ที่ส่งออกไปตามจำนวนที่ระบุ
$unwind แยกสมาชิกในฟิลด์อาร์เรย์จากอินพุตออกเป็นด็อกคิวเมนต์
$count นับจำนวนด็อกคิวเมนต์ทั้งหมดที่รับเข้ามา
$lookup เรียกดูข้อมูลจากด๊อกคิวเมนต์ที่อยู่คนละคอลเล็กชันกัน


- การจัดกลุ่มข้อมูลด้วย $group
เป็นการรวมกลุ่มด็อกคิวเมนต์ที่ข้อมูลเหมือนกันไว้ในกลุ่มเดียวกัน โดยมีฟิลด์ _id เก็บรายการของข้อมูลในแต่ละกลุ่มที่ไม่ซ้ำกัน
และสามารถเพิ่มฟิลด์ที่ใช้เก็บผลลัพธ์การคำนวณของข้อมูลในแต่ละกลุ่มตามนิพจน์ที่กำหนดไว้ เช่น ผลรวม จำนวน ค่าสูงสุด ค่าต่ำสุด และ ค่าเฉลี่ย

รูปแบบ
{
  $group: 
        {
          _id: <expression>, // Group By Expression
          <field> : { <accumulator1> : <expression1> },
        }
}

- _id จำเป็นต้องมี ใช้กำหนดว่าต้องการแบ่งกลุ่มตามกลุ่มของฟิลด์อะไร หรือหากไม่ต้องการให้กำหนดค่า null

- field สร้างฟิลด์จัดเก็บข้อมูลการคำนวณค่าในกลุ่มด้วยนิพจน์ที่กำหนด เช่น การหาจำนวน, ผลรวม

นิพจน์เพื่อคำนวณข้อมูลในกลุ่ม
$sum หาผลลรวมด็อกคิวเมนต์ภายในกลุ่ม
$avg หาค่าเฉลี่ยจากด็อกคิวเมนต์ภายในกลุ่ม
$min หาค่าต่ำสุดจากด็อกคิวเมนต์ภายในกลุ่ม
$max หาค่าสูงสุดจากด็อกคิวเมนต์ภายในกลุ่ม
$first หาค่าลำดับแรกจากด็อกคิวเมนต์ภายในกลุ่ม
$last หาค่าลำดับสุดท้ายจากด็อกคิวเมนต์ภายในกลุ่ม
$push แทรกค่าไปยังอาร์เรย์ในด็อกคิวเมนต์ผลลัพธ์
$addToSet แทรกค่าไปยังอาร์เรย์ในด็อกคิวเมนต์ผลลัพธ์แต่จะไม่สร้างซ้ำ


*/

// เรียกดูข้อมูลจากการเชื่อมคอลเล็กชันด้วย $lookup

/*
เป็นการเรียกดูข้อมูลด็อกคิวเมนต์จากต่างคอลเล็กชันกัน โดยกำหนดให้คอลเล็กชั่นหลักอยู่ฝั่งซ้ายแล้วเชื่อมกับคอลเล็กชันภายนอกอยู่ฝั่งขวา ซึ้งคอลเล็กชันทั้งสองจะต้องอยู่ในฐานข้อมูลเดียวกัน ผลลัพธ์ที่ได้จะมีฟิลด์อาร์เรย์ข้อมูลเพิ่มเข้ามา ซึ้งเกิดจากคอลเล็กชั่นฝั่งขวาที่เราเชื่อมนั่นเอง

รูปแบบ
{
  $lookup: {
    form: <collection to join>,
    locaField: <field from input documents>,
    foreigField: <field from documents of "from" collection>,
    as: <output array field>
  }
}

  Form: คอลเล็กชันที่จะเชื่อมต่อด้วยต้องอยู่ในฐานข้อมูลเดียวกัน
  localField: ฟิลด์จากคอลเล็กชันอินพุต
  foreignField: ฟิลด์จากคอลเล็กชันที่จะนำมาเชื่อมต่อ
  as: กำหนดชื่อฟิลด์อาร์เรย์ใหม่ที่เพิ่มเข้าไปในด็อกคิวเมนต์ผลลัพธ์

  การรวมข้อมูลด้วย Map-reduce
  คือการประมวลผลข้อมูลจำนวนมากเพื่อนำข้อมูลเหล่านั้นมารวมเข้าด้วยกัน 
  
  โดยเริ่มจากส่วน Map จะเข้าไปจับคู่ในแต่ละด็อกคิวเมนต์อินพุตที่เข้ามาตามเงื่อนไขที่ระบุในฟังก์ชัน (เหมือนกับเลือกข้อมูลด้วย match) โดยรวมกลุ่มจัดเก็บข้อมูลไว้ในรูปแบบของ คีย์ : ค่า

  จากนั้นจะมาที่ส่วน Reduce ประมวลผลข้อมูลที่ถูกรวมในด็อกคิวเมนต์

  และจัดเก็บไว้ในคอลเล็กชันตามที่ค่าที่กำหนด

  1. query ยอดขายปี 2020
  {
    name: "photoshop",
    cat: "graphic",
    sales: 2500,
    date: "2020-02-18"
  }

  2. Map (เหมือนกับเลือกข้อมูลด้วย match) โดยรวมกลุ่มจัดเก็บข้อมูลไว้ในรูปแบบของ คีย์ : ค่า
  {
    graphic: [2500, 2550]
  },
  {
    office: 1990
  }

  3.Reduce  จากนั้นจะมาที่ส่วน Reduce ประมวลผลข้อมูลที่ถูกรวมในด็อกคิวเมนต์
  และจัดเก็บไว้ในคอลเล็กชันตามที่ค่าที่กำหนด
  {
    "_id": "graphic",
    "value": 5050
  },
  {
    "_id": "office",
    "value": 1990
  }
  ค่าผลลัพธ์เก็บในคอลเล็กชัน total

  // query เรียกดูด็อกคิวเมนต์ยอดขายหนังสือในปี 2020 จากคอลเล็กชัน sales 
  จากนั้นให้ Map จับคู่ตามหมวดหนังสือ cat และ ยอดขาย sales

  สุดท้ายใช้ Reduce ประมวลผลข้อมูลที่รวมกลุ่มไว้ในอาร์เรย์ด้วยการหาผลรวม sum

  และจัดเก็บผลลัพธ์เป็นด็อกคิวเมนต์ไว้ในคอลเล็กชัน total 

  db.sales.mapReduce(
    function() {
      emit(this.cat, this.sales);
    },
    function (key, values) {
      return Array.sum(values)
    },
    {
      query: {
        date: /2020/
      },
      out: "total"
    }
  )
  

  db.sales.mapReduce() รวมกลุ่มข้อมูลในด็อกคิวเมนต์จากคอลเล็กชัน sales

  function() {
    emit(this.cat, this.sales);
  } เป็นการ map จับคู่ด็อกคิวเมนต์โดย emit เลือก this.cat หมวดหมู่, this.sales จัดเก็บค่ายอดขายไว้ด้วยกัน

  function(ket, values) {
    return Array.sum(values)
  } นำข้อมูล คีย์ : ค่า ที่จับคู่ไว้มาหาผลรวมของค่าในอาร์เรย์ Array.sum(values) แล้วคืนค่าผลลัพธ์กลับไป

  query: {
    date: /2020/ เลือกด็อกยอดขายปี 2020
  }

  out: "total" จัดเก็บผลลัพธ์ไว้ในคอลเล็กชัน total

  // db.total.find()

  การรวมข้อมูลด้วยไปป์ไลน์ของ Aggregation จะดีกว่าและเชื่อมต่อกันได้มากกว่า
  แต่ Map-reduce จะมีการทำงานบางอย่างที่ยืดหยุ่นกว่า Aggregation
 
*/